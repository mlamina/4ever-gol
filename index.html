<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life</title>
    <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/bulma@1.0.1/css/bulma.min.css"
    >
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.2.6/pixi.min.js" integrity="sha512-zc4TExgeBQ7b3Gs7JvLcztM9H9etw2zxwvzGU0TFKqPuxH4drXpPb9VjT7w78ahp04y36a1atVwgcxMw3cs2qg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0xFF0000,
        });

        const gridSize = 100;
        let zoomLevel = 3;
        const maxZoomLevel = 4;
        let isDragging = false;
        let startX, startY;
        let offsetX = 0, offsetY = 0;

        const colors = Array.from({ length: gridSize * gridSize }, () => Math.random() * 0xFFFFFF);
        const cells = [];

        function createGrid() {
            const cellSize = (app.screen.width / gridSize) * zoomLevel;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const graphics = new PIXI.Graphics();
                    graphics.beginFill(colors[i * gridSize + j]);
                    graphics.drawRect(i * cellSize + offsetX, j * cellSize + offsetY, cellSize, cellSize);
                    graphics.endFill();
                    app.stage.addChild(graphics);
                    cells.push(graphics);
                }
            }
        }

        function updateGrid() {
            const cellSize = (app.screen.width / gridSize) * zoomLevel;
            const liveCellCount = colors.filter(color => color === 0x000000).length;
            console.log(`Live cell count: ${liveCellCount}`);
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const graphics = cells[i * gridSize + j];
                    graphics.clear();
                    const color = colors[i * gridSize + j];
                    if (color === 0x000000) {
                        console.log(`[${i},${j}] Live cell with color: ${color}`);
                    }
                    graphics.beginFill(color);
                    graphics.drawRect(i * cellSize + offsetX, j * cellSize + offsetY, cellSize, cellSize);
                    graphics.endFill();
                }
            }
        }

        app.init().then(() => {
            document.body.appendChild(app.view);
            createGrid();
            app.view.addEventListener('mousedown', (event) => {
                isDragging = true;
                startX = event.clientX;
                startY = event.clientY;
            });

            app.view.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const dx = event.clientX - startX;
                    const dy = event.clientY - startY;
                    offsetX += dx;
                    offsetY += dy;
                    startX = event.clientX;
                    startY = event.clientY;
                    updateGrid();
                }
            });

            app.view.addEventListener('mouseup', () => {
                isDragging = false;
            });

            app.view.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            app.view.addEventListener('click', (event) => {
                const cellSize = (app.screen.width / gridSize) * zoomLevel;
                const x = Math.floor((event.clientX - offsetX) / cellSize);
                const y = Math.floor((event.clientY - offsetY) / cellSize);
                const message = JSON.stringify({ x, y });
                socket.send(message);
            });
            app.renderer.resize(window.innerWidth, window.innerHeight);
            updateGrid();
        });

        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
            updateGrid();
            console.log('resizing grid');
        });

        window.addEventListener('wheel', (event) => {
            if (event.deltaY < 0) {
                zoomLevel = Math.min(zoomLevel + 0.1, maxZoomLevel);
            } else {
                zoomLevel = Math.max(zoomLevel - 0.1, 1);
            }
            updateGrid();
        });

        const socket = new WebSocket("ws://localhost:8000/ws");

        socket.onmessage = function(event) {
            const liveCells = JSON.parse(event.data);
            // Reset all cells to white
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    colors[i * gridSize + j] = 0xFFFFFF;
                }
            }
            // Set live cells to black
            liveCells.forEach(([x, y]) => {
                colors[x * gridSize + y] = 0x000000;
            });
            updateGrid();
        };


    });
</script>
</body>
</html>
